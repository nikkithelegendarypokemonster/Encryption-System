#include <stdio.h>
#include <stdlib.h>
int cur_end=0,cur_start=0,min_burst=0,n=0,running=0;
int ready [200],qp=0,rp=0;
int queue[200];
typedef struct Proc
{
    int name;
    int AT,CPU1,S,E;
    int at[200],s[200],e[200];
    int ap,sp,ep;
} process[200],temporary;
process proc;
temporary temp;

void checker(int n)
{
    for(int i=0; i<n; i++)
    {
        if(proc[i].CPU1<0)
        {
            for(int k=i; k>0; k--)
            {
                temp=proc[k];
                proc[k]=proc[k-1];
                proc[k-1]=temp;
            }
        }
    }

}
int terminate(int n)
{
    for(int i=0; i<n; i++)
    {
        if(proc[i].CPU1>=0)
        {
            return 0;
        }
    }
    return 1;
}
int least_AT(int n)
{
    int min=proc[0].AT;
    for(int i=0; i<n; i++)
    {
        if(proc[i].AT<=min)
        {
            min=proc[i].AT;
        }
    }
    return min;
}
void sort(int s,int n){
    for(int i=s;i<n;i++){
        for(int k=s;k<n-1;k++){
            if(proc[k].AT>=proc[k+1].AT){
                    if(proc[k].AT==proc[k+1].AT){
                        if(proc[k+1].name<proc[k].name){
                            temp=proc[k];
                            proc[k]=proc[k+1];
                            proc[k+1]=temp;
                        }
                    }else{
                    temp=proc[k];
                    proc[k]=proc[k+1];
                    proc[k+1]=temp;
                    }

            }
        }
    }
}
int find_next(int s,int n,int start,int end,int running,int running_cpu){
    int min=running_cpu,loc=running;

printf("s:%d n:%d start:%d end:%d running:%d runcpu:%d\n",s,n,start,end,running,running_cpu);
        for(int i=s;i<n;i++){
            if(proc[i].AT>=start && proc[i].AT<=end && i!=running && proc[i].CPU1 >0){
                    if(proc[i].CPU1<=((min+proc[loc].AT)-proc[i].AT)){
                        if(proc[i].CPU1==((min+proc[loc].AT)-proc[i].AT)){
                            if(proc[i].AT<proc[loc].CPU1){
                                return i;
                            }
                        }else{
                        return i;
                        }
                    }
            }
             //min=proc[i].CPU1;
        }
printf("loc:%d\n",loc);

return loc;
}
int finder(int s,int n,int start,int end,int running){
int min=proc[s].CPU1,loc=s;
        for(int i=s;i<n;i++){
            if(proc[i].AT>=start && proc[i].AT<=end && i!=running && proc[i].CPU1 >0){
                    if(proc[i].CPU1<min){
                        loc=i;
                        min=proc[i].CPU1;
                    }
            }
        }
    return loc;
}
int main()
{
    int i=0,point=0,total=0,max_at=0,start=0,seeker=0;
//get nth processes
    printf("sjf\n");
    printf("How many processes:");
    scanf("%d",&n);
    total=n;
// get inputs
    for(int i=0; i<n; i++)
    {
        printf("P%d:\n",i+1);
        proc[i].name=i+1;
        printf("AT:");
        scanf("%d",&proc[i].AT);
        printf("CPU1:");
        scanf("%d",&proc[i].CPU1);
        if(proc[i].AT>=max_at){
            max_at=proc[i].AT;
        }
    }
    sort(i,n);
//set cur_end by least AT and cur_start by least_AT
    start=cur_start=least_AT(n);
    cur_end=proc[i].AT+proc[i].CPU1;
    /*past=i;
    find_next(i,n,cur_start,cur_end,past);*/
//  while(cur_start<=max_at)
 //   {
        checker(n);
        while(proc[i].CPU1<0 && i<n)
        {
            i++;
        }

        //SORT BY AT
        sort(i,n);
        if(seeker==0){
            point=find_next(i,n,start,cur_end,running,proc[running].CPU1);
        }else{
             point=find_next(i,n,start,cur_end+proc[running].CPU1,running,proc[running].CPU1);
        seeker=0;
        }
        printf("point:%d\n",point);
      //  printf("point:%d running:%d curstart:%d curend:%d\n",point,running,cur_start,cur_end);
        //START
            proc[running].S=cur_start;
            proc[running].s[proc[running].sp]=proc[running].S;
            proc[running].sp++;
        if(point==running && proc[running].CPU1<=proc[point].AT){
            //END
            proc[running].E=proc[running].S+proc[running].CPU1;
            cur_end=proc[running].E;
            point=finder(i,n,start,cur_end,running);
            printf("\npoint:%d\n",point);
            seeker=1;
            proc[running].CPU1=-1;
        }else{


            //END
            proc[running].E=proc[point].AT;
            cur_end=proc[running].E;
            proc[running].CPU1=(proc[running].CPU1 + proc[running].S)-proc[point].AT;
        }
        proc[running].e[proc[running].ep]=proc[running].E;
        proc[running].ep++;
        cur_start=cur_end;
        running=point;


 //   }
for(int i=0;i<total;i++){
    printf("P%d\n",proc[i].name);
    printf("AT: ");
    for(int k=0;k<proc[i].ap;k++){
        printf("%d, ",proc[i].at[k]);
    }
    printf("\n");
    printf("CPU1: %d\n",proc[i].CPU1);
    printf("Start: ");
    for(int k=0;k<proc[i].sp;k++){
        printf("%d, ",proc[i].s[k]);
    }
    printf("\n");
    printf("End: ");
    for(int k=0;k<proc[i].ep;k++){
        printf("%d,",proc[i].e[k]);
    }
    printf("\n");
}
    return 0;
}
/*
5
2
1
1
5
4
1
0
6
2
3

6
0
7
1
5
2
3
3
1
4
2
5
1

*/
